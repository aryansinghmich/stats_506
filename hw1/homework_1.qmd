---
title: "Problem Set 1"
author: "Aryan Singh"
format:
  html:
    embed-resources: true
    code-fold: true
---

# Problem 1

```{r}
# environment set up
setwd("/Users/aryansingh/Desktop/stats_506_git/hw1")
pacman::p_load(tidyverse)
```

## Part A

```{r}
# data
abalone_data <- read.csv("abalone/abalone.data", header = F) %>% `colnames<-`(c(
    "sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings"
))
```

## Part B

```{r}
table(abalone_data$sex)
```

## Part C

### 1.

```{r}
weight_names <- c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
weights <- abalone_data[, weight_names]
cor(weights, abalone_data$rings)
```

The weight with the highest correlation with the rings is Shell Weight (R = 0.6275740).

### 2.

From cor_table (see below, Part D), for Shell Weight, the sex of I has the highest correlation (0.725).

### 3.

```{r}
abalone_data[abalone_data$rings == max(abalone_data$rings), c(weight_names, "rings")]
```

The abalone with the most rings (29) had the following weights:

-   whole: 1.8075
-   shucked: 0.7055
-   viscera: 0.3215
-   shell: 0.475

### 4.

```{r}
# we can use mean here as the input is a vector of TRUE, FALSE which R will treat as 1, 0 
# thus mean is equivalent the summing the TRUE entries over all observations
mean(abalone_data$viscera_weight > abalone_data$shell_weight) * 100
```

About 6.51% of abalones have a viscera weight larger than shell weight.

## Part D

```{r}
cor_table <- abalone_data %>% group_by(sex) %>% summarise(across(all_of(weight_names), ~ cor(.x, rings), .names = "{.col}")) %>% ungroup()
cor_table
```

## Part E

```{r}
# M vs F
t.test(rings ~ sex, data = subset(abalone_data, sex %in% c("M", "F")))
# M vs I
t.test(rings ~ sex, data = subset(abalone_data, sex %in% c("M", "I")))
# F vs I
t.test(rings ~ sex, data = subset(abalone_data, sex %in% c("F", "I")))
```

# Problem 2

## Part A

```{r}
food_expend <- read.csv("hw1/food_expend/food_expenditure.csv")
```

## Part B

```{r}
colnames(food_expend) <- c("id", "age", "num_food_dependents", "state", "currency", "tot_exp", "groceries_exp", "dining_out_exp", "misc_exp", "dine_out_ct", "alcohol_inc", "program")
```

## Part C
```{r}
nrow(food_expend)
food_expend <- subset(food_expend, currency == "USD")
nrow(food_expend)
```

# Problem 3 - Collatz conjecture

## Part A

```{r}
nextCollatz <- function(num){
    if (!is.numeric(num)) {
        stop("Input was not numeric")
    } else if (num < 1) {
        stop("Input was not positive")
    } else if (num %% 1 != 0) {
        stop("Input was not an integer")
    }

    if (num %% 2 == 0) {
        return(num/2)
    } else {
        return(3*num + 1)
    }
}

nextCollatz(5)
nextCollatz(16)
```

## Part B

```{r}
collatzSequence <- function(num) {
    seq <- c(num)
    while (num != 1) {
        num <- nextCollatz(num)
        seq <- append(seq, num)
    }
    return(list(seq,length(seq)))
}

collatzSequence(5)
collatzSequence(19)
```

## Part C

```{r}
collatz_lens <- sapply(100:500, function(x) collatzSequence(x)[[2]])

short_start_val <- which.min(collatz_lens) + 99
long_start_val <- which.max(collatz_lens) + 99

short_seq_len <- min(collatz_lens)
long_seq_len <- max(collatz_lens)

list(short = list(start = short_start_val, length = short_seq_len),
  long  = list(start = long_start_val,  length = long_seq_len))
```