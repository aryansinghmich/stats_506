---
title: "Problem Set 1"
author: "Aryan Singh"
format:
  html:
    embed-resources: true
    code-fold: true
---

<https://github.com/aryansinghmich/stats_506>

```{r}
# environment set up
setwd("/Users/aryansingh/Desktop/stats_506_git/hw1")
pacman::p_load(tidyverse)
```

# Problem 1

## Part A

```{r}
# data
abalone_data <- read.csv("abalone/abalone.data", header = F) %>% `colnames<-`(c(
    "sex", "length", "diameter", "height", "whole_weight", "shucked_weight", "viscera_weight", "shell_weight", "rings"
))
```

## Part B

```{r}
table(abalone_data$sex)
```

## Part C

### 1.

```{r}
weight_names <- c("whole_weight", "shucked_weight", "viscera_weight", "shell_weight")
weights <- abalone_data[, weight_names]
cor(weights, abalone_data$rings)
```

The weight with the highest correlation with the rings is Shell Weight (R = 0.6275740).

### 2.

```{r}
abalone_data %>% group_by(sex) %>% summarise(correlation = cor(shell_weight, rings), .groups = "drop")
```

For Shell Weight, the sex of I has the highest correlation (0.725).

### 3.

```{r}
abalone_data[abalone_data$rings == max(abalone_data$rings), c(weight_names, "rings")]
```

The abalone with the most rings (29) had the following weights:

-   whole: 1.8075
-   shucked: 0.7055
-   viscera: 0.3215
-   shell: 0.475

### 4.

```{r}
# we can use mean here as the input is a vector of TRUE, FALSE which R will treat as 1, 0 
# thus mean is equivalent the summing the TRUE entries over all observations
mean(abalone_data$viscera_weight > abalone_data$shell_weight) * 100
```

About 6.51% of abalones have a viscera weight larger than shell weight.

## Part D

```{r}
cor_table <- abalone_data %>% group_by(sex) %>% summarise(across(all_of(weight_names), ~ cor(.x, rings), .names = "{.col}")) %>% ungroup()
cor_table
```

## Part E

```{r}
#' Function to perform a two-sample Student's t-test
#' It compares the means of two groups using the pooled-variance formulation
#' of the two-sample t-test. The function returns group means, the t-statistic,
#' degrees of freedom, and the p-value for the test.
#'
#' @param formula a formula of the form response ~ group, where group has only two levels
#' @param data a data frame containing the variables in the formula
#' @return a list of group means, the t-statistic, degrees of freedom, and the p-value for the test
t_tester <- function(formula, data) {
  #response ~ group
  mf <- model.frame(formula, data)
  y <- mf[[1]]
  g <- mf[[2]]
  
  x <- y[g == unique(g)[1]]
  z <- y[g == unique(g)[2]]
  
  nx <- length(x)
  nz <- length(z)
  mx <- mean(x)
  mz <- mean(z)
  vx <- var(x)
  vz <- var(z)
  
  sp2 <- ((nx - 1) * vx + (nz - 1) * vz) / (nx + nz - 2) # pooled var
  t_stat <- (mx - mz) / sqrt(sp2 * (1/nx + 1/nz)) # t test
  df <- nx + nz - 2 # degrees of freedom
  p_val <- 2 * pt(-abs(t_stat), df) #2-side p_val
  
  return(list(group_means = c(mean1 = mx, mean2 = mz), t_stat = t_stat, df = df,p_value = p_val))
}
```

```{r}
# M vs F
t.test(rings ~ sex, data = subset(abalone_data, sex %in% c("M", "F")))
t_tester(rings ~ sex, data = subset(abalone_data, sex %in% c("M", "F")))
# M vs I
t.test(rings ~ sex, data = subset(abalone_data, sex %in% c("M", "I")))
t_tester(rings ~ sex, data = subset(abalone_data, sex %in% c("M", "I")))
# F vs I
t.test(rings ~ sex, data = subset(abalone_data, sex %in% c("F", "I")))
t_tester(rings ~ sex, data = subset(abalone_data, sex %in% c("F", "I")))
```

The t-tests show that the mean number of rings differs significantly across sexes. Females have slightly more rings than males, and both have substantially more rings than infants. These differences are all highly significant (p \< 0.001), which indicates that sex is associated with abalone age.

# Problem 2

## Part A

```{r}
food_expend <- read.csv("food_expend/food_expenditure.csv")
```

## Part B

```{r}
colnames(food_expend) <- c("id", "age", "num_food_dependents", "state", "currency", "tot_exp", "groceries_exp", "dining_out_exp", "misc_exp", "dine_out_ct", "alcohol_inc", "program")
```

## Part C

```{r}
nrow(food_expend)
food_expend <- subset(food_expend, currency == "USD")
nrow(food_expend)
```

### Part D

```{r}
food_expend <- subset(food_expend, age >= 14)
```

Subsetted observations age to the legal minimum working age or older (\>14yrs old).

### Part E

```{r}
food_expend <- subset(food_expend, !(state %in% c("", "AK", "HI")))
```

Excluded empty state rows. Removed entries from the noncontiguous states (states not connected to the mainland USA), Alaska and Hawaii.

### Part F

```{r}
# clean out ~ in data
food_expend$tot_exp <- gsub("~", "", food_expend$tot_exp)
food_expend$tot_exp <- as.numeric(food_expend$tot_exp)

# add NAs to empty entries
exp_cols <- c("tot_exp", "groceries_exp", "dining_out_exp", "misc_exp")
for (col in exp_cols) {
  x <- food_expend[[col]]
  x <- as.character(x)
  x[x == ""] <- NA
  food_expend[[col]] <- as.numeric(x)
}

# drop neg vals
food_expend <- subset(food_expend, !(groceries_exp < 0 | dining_out_exp < 0 | misc_exp < 0 | tot_exp < 0))
```

Cleaned the total expenses column to remove unwanted characters (\~) and coerce into a numeric. Added NA to the empty entries in the expense columns. Dropped rows that had negative values in the expense columns.

### Part G

```{r}
food_expend <- subset(food_expend, !(dine_out_ct = 30))
```

Excluded individuals who dined out 30 or more times.

### Part H

```{r}
nrow(food_expend)
```

# Problem 3 - Collatz conjecture

## Part A

```{r}
#' Function to calculate the next Collatz number in sequence given a integer input
#' It divides input by 2 if the input is even (num/2)
#' It multiplies input by 3 and then adds 1 if the input is odd (3*num + 1)
#'
#' @param num a positive integer numeric
#' @return The next colltaz number in the sequence based on `num`
nextCollatz <- function(num){
    if (!is.numeric(num)) {
        stop("Input was not numeric")
    } else if (num < 1) {
        stop("Input was not positive")
    } else if (num %% 1 != 0) {
        stop("Input was not an integer")
    }

    if (num %% 2 == 0) {
        return(num/2)
    } else {
        return(3*num + 1)
    }
}

nextCollatz(5)
nextCollatz(16)
```

## Part B

```{r}
#' Function to generate a Collatz sequence based on integer input
#' It continues to irratively run `nextCollatz` on the input until it reaches the value of 1.
#' It returns a list with a vector of the sequence and a numeric with the length of the sequence.
#'
#' @param num a positive integer numeric
#' @return a list with a vector of the Collatz sequence and a numeric for the sequence length
collatzSequence <- function(num) {
    seq <- c(num)
    while (num != 1) {
        num <- nextCollatz(num)
        seq <- append(seq, num)
    }
    return(list(seq,length(seq)))
}

collatzSequence(5)
collatzSequence(19)
```

## Part C

```{r}
collatz_lens <- sapply(100:500, function(x) collatzSequence(x)[[2]])

short_start_val <- which.min(collatz_lens) + 99
long_start_val <- which.max(collatz_lens) + 99

short_seq_len <- min(collatz_lens)
long_seq_len <- max(collatz_lens)

list(short = list(start = short_start_val, length = short_seq_len),
  long = list(start = long_start_val,  length = long_seq_len))
```

Between 100 and 500, the shortest Collatz sequence starts at 128 with length 8, while the longest starts at 327 with length 144.